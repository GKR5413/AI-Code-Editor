// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "terminal.proto" (package "terminal", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { TerminalService } from "./terminal";
import type { KillSessionResponse } from "./terminal";
import type { KillSessionRequest } from "./terminal";
import type { ListSessionsResponse } from "./terminal";
import type { ListSessionsRequest } from "./terminal";
import type { SessionResponse } from "./terminal";
import type { SessionRequest } from "./terminal";
import type { OutputChunk } from "./terminal";
import type { StreamRequest } from "./terminal";
import type { ServerStreamingCall } from "@protobuf-ts/runtime-rpc";
import type { OutputResponse } from "./terminal";
import type { OutputRequest } from "./terminal";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { CommandResponse } from "./terminal";
import type { CommandRequest } from "./terminal";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * Terminal service for communication between Gemini agent and terminal
 *
 * @generated from protobuf service terminal.TerminalService
 */
export interface ITerminalServiceClient {
    /**
     * Execute a command in the terminal
     *
     * @generated from protobuf rpc: ExecuteCommand
     */
    executeCommand(input: CommandRequest, options?: RpcOptions): UnaryCall<CommandRequest, CommandResponse>;
    /**
     * Get terminal output
     *
     * @generated from protobuf rpc: GetOutput
     */
    getOutput(input: OutputRequest, options?: RpcOptions): UnaryCall<OutputRequest, OutputResponse>;
    /**
     * Stream real-time terminal output
     *
     * @generated from protobuf rpc: StreamOutput
     */
    streamOutput(input: StreamRequest, options?: RpcOptions): ServerStreamingCall<StreamRequest, OutputChunk>;
    /**
     * Create a new terminal session
     *
     * @generated from protobuf rpc: CreateSession
     */
    createSession(input: SessionRequest, options?: RpcOptions): UnaryCall<SessionRequest, SessionResponse>;
    /**
     * List active terminal sessions
     *
     * @generated from protobuf rpc: ListSessions
     */
    listSessions(input: ListSessionsRequest, options?: RpcOptions): UnaryCall<ListSessionsRequest, ListSessionsResponse>;
    /**
     * Kill a terminal session
     *
     * @generated from protobuf rpc: KillSession
     */
    killSession(input: KillSessionRequest, options?: RpcOptions): UnaryCall<KillSessionRequest, KillSessionResponse>;
}
/**
 * Terminal service for communication between Gemini agent and terminal
 *
 * @generated from protobuf service terminal.TerminalService
 */
export class TerminalServiceClient implements ITerminalServiceClient, ServiceInfo {
    typeName = TerminalService.typeName;
    methods = TerminalService.methods;
    options = TerminalService.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * Execute a command in the terminal
     *
     * @generated from protobuf rpc: ExecuteCommand
     */
    executeCommand(input: CommandRequest, options?: RpcOptions): UnaryCall<CommandRequest, CommandResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<CommandRequest, CommandResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Get terminal output
     *
     * @generated from protobuf rpc: GetOutput
     */
    getOutput(input: OutputRequest, options?: RpcOptions): UnaryCall<OutputRequest, OutputResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<OutputRequest, OutputResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Stream real-time terminal output
     *
     * @generated from protobuf rpc: StreamOutput
     */
    streamOutput(input: StreamRequest, options?: RpcOptions): ServerStreamingCall<StreamRequest, OutputChunk> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<StreamRequest, OutputChunk>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Create a new terminal session
     *
     * @generated from protobuf rpc: CreateSession
     */
    createSession(input: SessionRequest, options?: RpcOptions): UnaryCall<SessionRequest, SessionResponse> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<SessionRequest, SessionResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * List active terminal sessions
     *
     * @generated from protobuf rpc: ListSessions
     */
    listSessions(input: ListSessionsRequest, options?: RpcOptions): UnaryCall<ListSessionsRequest, ListSessionsResponse> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<ListSessionsRequest, ListSessionsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Kill a terminal session
     *
     * @generated from protobuf rpc: KillSession
     */
    killSession(input: KillSessionRequest, options?: RpcOptions): UnaryCall<KillSessionRequest, KillSessionResponse> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<KillSessionRequest, KillSessionResponse>("unary", this._transport, method, opt, input);
    }
}
